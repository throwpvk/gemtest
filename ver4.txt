import React, { useRef, useEffect, useState } from 'react';
import { MessageCircle, MapPin, ShoppingBag, Home, User } from 'lucide-react';

// ============================================
// SPATIAL GRID - Advanced Version
// ============================================

class SpatialGrid {
  constructor(cellSize = 200) {
    this.cellSize = cellSize;
    this.grid = new Map();
  }
  
  // T√≠nh grid key t·ª´ v·ªã tr√≠ x
  getGridKey(x) {
    return Math.floor(x / this.cellSize);
  }
  
  // Th√™m object v√†o grid
  insert(obj) {
    // Object c√≥ th·ªÉ chi·∫øm nhi·ªÅu cells
    const startKey = this.getGridKey(obj.x);
    const endKey = this.getGridKey(obj.x + (obj.width || this.cellSize));
    
    // L∆∞u object v√†o t·∫•t c·∫£ cells n√≥ chi·∫øm
    for (let key = startKey; key <= endKey; key++) {
      if (!this.grid.has(key)) {
        this.grid.set(key, []);
      }
      // Tr√°nh tr√πng l·∫∑p
      if (!this.grid.get(key).includes(obj)) {
        this.grid.get(key).push(obj);
      }
    }
    
    // L∆∞u th√¥ng tin ƒë·ªÉ c√≥ th·ªÉ x√≥a sau
    obj._gridKeys = { start: startKey, end: endKey };
  }
  
  // X√≥a object kh·ªèi grid
  remove(obj) {
    if (!obj._gridKeys) return;
    
    for (let key = obj._gridKeys.start; key <= obj._gridKeys.end; key++) {
      if (this.grid.has(key)) {
        const bucket = this.grid.get(key);
        const index = bucket.indexOf(obj);
        if (index > -1) {
          bucket.splice(index, 1);
        }
      }
    }
    
    delete obj._gridKeys;
  }
  
  // Update v·ªã tr√≠ object
  update(obj) {
    this.remove(obj);
    this.insert(obj);
  }
  
  // Query objects trong v√πng
  query(left, right, objectType = null) {
    const startKey = this.getGridKey(left);
    const endKey = this.getGridKey(right);
    const results = new Set(); // D√πng Set ƒë·ªÉ tr√°nh tr√πng l·∫∑p
    
    for (let key = startKey; key <= endKey; key++) {
      if (this.grid.has(key)) {
        this.grid.get(key).forEach(obj => {
          // Filter theo lo·∫°i object n·∫øu c·∫ßn
          if (!objectType || obj.objectType === objectType) {
            results.add(obj);
          }
        });
      }
    }
    
    return Array.from(results);
  }
  
  // Debug: Show grid info
  getStats() {
    let totalObjects = 0;
    this.grid.forEach(bucket => totalObjects += bucket.length);
    return {
      buckets: this.grid.size,
      totalObjects: totalObjects
    };
  }
}

// ============================================
// GAME ENGINE - Enhanced Version
// ============================================

class GameEngine {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d', { alpha: false });
    this.width = canvas.width;
    this.height = canvas.height;
    
    // Camera
    this.camera = {
      x: 0,
      targetX: 0,
      smoothing: 0.1
    };
    
    // World
    this.worldWidth = 40000;
    
    // Spatial Grid v·ªõi cell size 200px
    this.spatialGrid = new SpatialGrid(200);
    
    // Game objects - ph√¢n lo·∫°i r√µ r√†ng
    this.player = null;
    this.backgrounds = []; // Background cells (k√≠ch th∆∞·ªõc kh√°c nhau)
    this.buildings = [];   // Buildings (shops, houses...)
    this.items = [];       // Collectible items
    this.npcs = [];        // Other NPCs
    
    // Performance
    this.lastTime = 0;
    this.fps = 0;
    this.running = false;
    
    // Sprite sheet
    this.spriteSheet = null;
    this.spriteLoaded = false;
    
    // Events
    this.onCollision = null;
    this.currentCollisions = new Map(); // Track active collisions
  }
  
  async loadSpriteSheet() {
    return new Promise((resolve) => {
      // Simulated sprite sheet
      this.spriteSheet = document.createElement('canvas');
      this.spriteSheet.width = 40000;
      this.spriteSheet.height = 500;
      const ctx = this.spriteSheet.getContext('2d');
      
      // Draw varied backgrounds
      for (let i = 0; i < 200; i++) {
        const x = i * 200;
        const hue = (i * 360 / 200) % 360;
        
        // Background
        ctx.fillStyle = `hsl(${hue}, 40%, ${40 + Math.random() * 20}%)`;
        ctx.fillRect(x, 0, 200, 500);
        
        // Add variety
        if (i % 5 === 0) {
          // Shop-like pattern
          ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
          ctx.fillRect(x + 10, 200, 180, 300);
        } else if (i % 3 === 0) {
          // House-like pattern
          ctx.fillStyle = `hsl(${hue}, 50%, 40%)`;
          ctx.fillRect(x + 30, 250, 140, 250);
        }
      }
      
      this.spriteLoaded = true;
      resolve();
    });
  }
  
  initWorld() {
    // 1. CREATE BACKGROUNDS (k√≠ch th∆∞·ªõc kh√°c nhau)
    const layouts = [
      { width: 150, type: 'narrow' },
      { width: 200, type: 'normal' },
      { width: 250, type: 'wide' },
      { width: 300, type: 'plaza' }
    ];
    
    let currentX = 0;
    let cellIndex = 0;
    
    while (currentX < this.worldWidth) {
      const layout = layouts[Math.floor(Math.random() * layouts.length)];
      
      const cell = {
        id: `bg-${cellIndex}`,
        objectType: 'background',
        type: layout.type,
        x: currentX,
        y: 0,
        width: layout.width,
        height: 500,
        spriteX: Math.floor(currentX / 200) * 200 // Map to sprite sheet
      };
      
      this.backgrounds.push(cell);
      this.spatialGrid.insert(cell);
      
      currentX += layout.width;
      cellIndex++;
    }
    
    // 2. CREATE BUILDINGS (shops, houses - k√≠ch th∆∞·ªõc ƒëa d·∫°ng)
    for (let i = 0; i < 50; i++) {
      const buildingTypes = [
        { type: 'shop', width: 180, height: 250, color: '#FF6B6B', icon: 'üè™', 
          name: '„Ç≥„É≥„Éì„Éã', nameEn: 'Convenience Store' },
        { type: 'restaurant', width: 220, height: 280, color: '#4ECDC4', icon: 'üçú',
          name: '„É¨„Çπ„Éà„É©„É≥', nameEn: 'Restaurant' },
        { type: 'house', width: 160, height: 200, color: '#95E1D3', icon: 'üè†',
          name: 'ÂÆ∂', nameEn: 'House' },
        { type: 'school', width: 300, height: 350, color: '#F38181', icon: 'üè´',
          name: 'Â≠¶Ê†°', nameEn: 'School' }
      ];
      
      const template = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
      
      const building = {
        id: `building-${i}`,
        objectType: 'building',
        ...template,
        x: Math.random() * (this.worldWidth - template.width),
        y: 500 - template.height,
        interactable: true,
        hasQuest: Math.random() > 0.7
      };
      
      this.buildings.push(building);
      this.spatialGrid.insert(building);
    }
    
    // 3. CREATE ITEMS (collectibles - k√≠ch th∆∞·ªõc nh·ªè)
    for (let i = 0; i < 30; i++) {
      const itemTypes = [
        { type: 'coin', width: 30, height: 30, color: '#FFD700', icon: 'üí∞', points: 10 },
        { type: 'book', width: 35, height: 35, color: '#8B4513', icon: 'üìö', points: 50 },
        { type: 'gift', width: 40, height: 40, color: '#FF1493', icon: 'üéÅ', points: 100 }
      ];
      
      const template = itemTypes[Math.floor(Math.random() * itemTypes.length)];
      
      const item = {
        id: `item-${i}`,
        objectType: 'item',
        ...template,
        x: Math.random() * this.worldWidth,
        y: 400,
        collected: false,
        bobOffset: Math.random() * Math.PI * 2 // For animation
      };
      
      this.items.push(item);
      this.spatialGrid.insert(item);
    }
    
    // 4. CREATE NPCS
    for (let i = 0; i < 8; i++) {
      const npcTypes = [
        { type: 'student', width: 50, height: 90, color: '#4A90E2', speed: 1.5 },
        { type: 'elderly', width: 45, height: 85, color: '#9B59B6', speed: 0.8 },
        { type: 'businessman', width: 55, height: 95, color: '#34495E', speed: 2 }
      ];
      
      const template = npcTypes[Math.floor(Math.random() * npcTypes.length)];
      
      const npc = {
        id: `npc-${i}`,
        objectType: 'npc',
        ...template,
        x: Math.random() * this.worldWidth,
        y: 330,
        vx: (Math.random() - 0.5) * 2 * template.speed,
        hasDialog: true,
        dialog: this.getRandomDialog(template.type)
      };
      
      this.npcs.push(npc);
      this.spatialGrid.insert(npc);
    }
    
    // 5. CREATE PLAYER
    this.player = {
      id: 'player',
      objectType: 'player',
      x: 400,
      y: 320,
      width: 60,
      height: 100,
      vx: 0,
      speed: 5,
      score: 0
    };
  }
  
  getRandomDialog(npcType) {
    const dialogs = {
      student: [
        { jp: '„Åì„Çì„Å´„Å°„ÅØÔºÅ', en: 'Hello!' },
        { jp: 'ÂãâÂº∑„ÅØÂ§ßÂ§â„Åß„Åô„ÄÇ', en: 'Studying is hard.' }
      ],
      elderly: [
        { jp: '„ÅÑ„ÅÑÂ§©Ê∞ó„Åß„Åô„Å≠„ÄÇ', en: 'Nice weather, isn\'t it?' },
        { jp: '„ÇÜ„Å£„Åè„ÇäÊ≠©„Åç„Åæ„Åó„Çá„ÅÜ„ÄÇ', en: 'Let\'s walk slowly.' }
      ],
      businessman: [
        { jp: 'ÊÄ•„ÅÑ„Åß„ÅÑ„Åæ„ÅôÔºÅ', en: 'I\'m in a hurry!' },
        { jp: '‰ºöË≠∞„Å´ÈÅÖ„Çå„Åæ„Åô„ÄÇ', en: 'I\'ll be late for the meeting.' }
      ]
    };
    
    const list = dialogs[npcType] || dialogs.student;
    return list[Math.floor(Math.random() * list.length)];
  }
  
  update(deltaTime) {
    // Update player
    if (this.player.vx !== 0) {
      this.player.x += this.player.vx;
      this.player.x = Math.max(0, Math.min(this.worldWidth - this.player.width, this.player.x));
      
      this.camera.targetX = this.player.x - this.width / 2 + this.player.width / 2;
      this.camera.targetX = Math.max(0, Math.min(this.worldWidth - this.width, this.camera.targetX));
    }
    
    this.camera.x += (this.camera.targetX - this.camera.x) * this.camera.smoothing;
    
    // Update NPCs
    this.npcs.forEach(npc => {
      const oldX = npc.x;
      npc.x += npc.vx;
      
      if (npc.x < 0 || npc.x > this.worldWidth - npc.width) {
        npc.vx *= -1;
      }
      
      // Update spatial grid if moved significantly
      if (Math.abs(npc.x - oldX) > 5) {
        this.spatialGrid.update(npc);
      }
    });
    
    // Animate items (bobbing effect)
    this.items.forEach(item => {
      if (!item.collected) {
        item.bobOffset += 0.05;
      }
    });
    
    // Collision detection
    this.checkCollisions();
  }
  
  checkCollisions() {
    // Define viewport with buffer
    const viewport = {
      left: this.player.x - 100,
      right: this.player.x + this.player.width + 100
    };
    
    // Clear old collisions
    const newCollisions = new Map();
    
    // 1. Check BUILDINGS
    const nearbyBuildings = this.spatialGrid.query(
      viewport.left,
      viewport.right,
      'building'
    );
    
    nearbyBuildings.forEach(building => {
      if (this.checkAABB(this.player, building)) {
        newCollisions.set(building.id, { type: 'building', target: building });
        
        // Trigger event if new collision
        if (!this.currentCollisions.has(building.id)) {
          if (this.onCollision) {
            this.onCollision({ type: 'building', target: building });
          }
        }
      }
    });
    
    // 2. Check ITEMS
    const nearbyItems = this.spatialGrid.query(
      viewport.left,
      viewport.right,
      'item'
    );
    
    nearbyItems.forEach(item => {
      if (!item.collected && this.checkAABB(this.player, item)) {
        item.collected = true;
        this.player.score += item.points;
        this.spatialGrid.remove(item);
        
        if (this.onCollision) {
          this.onCollision({ type: 'item', target: item });
        }
      }
    });
    
    // 3. Check NPCs
    const nearbyNPCs = this.spatialGrid.query(
      viewport.left,
      viewport.right,
      'npc'
    );
    
    nearbyNPCs.forEach(npc => {
      if (this.checkAABB(this.player, npc)) {
        newCollisions.set(npc.id, { type: 'npc', target: npc });
        
        if (!this.currentCollisions.has(npc.id)) {
          if (this.onCollision) {
            this.onCollision({ type: 'npc', target: npc });
          }
        }
      }
    });
    
    this.currentCollisions = newCollisions;
  }
  
  checkAABB(a, b) {
    return a.x < b.x + b.width &&
           a.x + a.width > b.x &&
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
  }
  
  render() {
    // Clear
    this.ctx.fillStyle = '#87CEEB';
    this.ctx.fillRect(0, 0, this.width, this.height);
    
    if (!this.spriteLoaded) return;
    
    // 1. Render BACKGROUNDS
    this.backgrounds.forEach(bg => {
      const screenX = bg.x - this.camera.x;
      
      if (screenX > -bg.width && screenX < this.width) {
        this.ctx.drawImage(
          this.spriteSheet,
          bg.spriteX, 0, 200, 500,
          screenX, bg.y, bg.width, bg.height
        );
      }
    });
    
    // 2. Render ITEMS
    this.items.forEach(item => {
      if (item.collected) return;
      
      const screenX = item.x - this.camera.x;
      if (screenX > -item.width && screenX < this.width) {
        const bobY = Math.sin(item.bobOffset) * 10;
        
        this.ctx.fillStyle = item.color;
        this.ctx.fillRect(screenX, item.y + bobY, item.width, item.height);
        
        // Icon
        this.ctx.font = '24px Arial';
        this.ctx.fillText(item.icon, screenX + 5, item.y + bobY + 25);
      }
    });
    
    // 3. Render BUILDINGS
    this.buildings.forEach(building => {
      const screenX = building.x - this.camera.x;
      
      if (screenX > -building.width && screenX < this.width) {
        // Building body
        this.ctx.fillStyle = building.color;
        this.ctx.fillRect(screenX, building.y, building.width, building.height);
        
        // Border
        this.ctx.strokeStyle = '#333';
        this.ctx.lineWidth = 3;
        this.ctx.strokeRect(screenX, building.y, building.width, building.height);
        
        // Icon
        this.ctx.font = 'bold 40px Arial';
        this.ctx.fillText(building.icon, screenX + building.width / 2 - 20, building.y + 60);
        
        // Quest indicator
        if (building.hasQuest) {
          this.ctx.fillStyle = '#FFD700';
          this.ctx.fillText('!', screenX + building.width - 30, building.y + 40);
        }
      }
    });
    
    // 4. Render NPCs
    this.npcs.forEach(npc => {
      const screenX = npc.x - this.camera.x;
      
      if (screenX > -npc.width && screenX < this.width) {
        this.ctx.fillStyle = npc.color;
        this.ctx.fillRect(screenX, npc.y, npc.width, npc.height);
        
        // Face
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(screenX + 12, npc.y + 20, 10, 10);
        this.ctx.fillRect(screenX + 28, npc.y + 20, 10, 10);
      }
    });
    
    // 5. Render PLAYER
    const playerScreenX = this.player.x - this.camera.x;
    this.ctx.fillStyle = '#FF6B6B';
    this.ctx.fillRect(playerScreenX, this.player.y, this.player.width, this.player.height);
    
    this.ctx.fillStyle = '#000';
    this.ctx.fillRect(playerScreenX + 15, this.player.y + 25, 12, 12);
    this.ctx.fillRect(playerScreenX + 33, this.player.y + 25, 12, 12);
    this.ctx.fillStyle = '#FFF';
    this.ctx.fillRect(playerScreenX + 20, this.player.y + 60, 20, 5);
    
    // Debug info
    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    this.ctx.fillRect(10, 10, 200, 90);
    this.ctx.fillStyle = '#0F0';
    this.ctx.font = '14px monospace';
    this.ctx.fillText(`FPS: ${this.fps}`, 20, 30);
    this.ctx.fillText(`Score: ${this.player.score}`, 20, 50);
    
    const stats = this.spatialGrid.getStats();
    this.ctx.fillText(`Grid: ${stats.buckets} buckets`, 20, 70);
    this.ctx.fillText(`Objects: ${stats.totalObjects}`, 20, 90);
  }
  
  gameLoop(currentTime) {
    if (!this.running) return;
    
    const deltaTime = currentTime - this.lastTime;
    this.lastTime = currentTime;
    this.fps = Math.round(1000 / deltaTime);
    
    this.update(deltaTime);
    this.render();
    
    requestAnimationFrame((time) => this.gameLoop(time));
  }
  
  start() {
    this.running = true;
    this.lastTime = performance.now();
    requestAnimationFrame((time) => this.gameLoop(time));
  }
  
  stop() {
    this.running = false;
  }
  
  movePlayer(direction) {
    this.player.vx = direction * this.player.speed;
  }
  
  stopPlayer() {
    this.player.vx = 0;
  }
}

// ============================================
// REACT COMPONENT
// ============================================

export default function JapaneseCityGame() {
  const canvasRef = useRef(null);
  const engineRef = useRef(null);
  const [collision, setCollision] = useState(null);
  const [gameLoaded, setGameLoaded] = useState(false);
  const [showDialog, setShowDialog] = useState(false);
  const [score, setScore] = useState(0);
  const keysPressed = useRef(new Set());

  useEffect(() => {
    const canvas = canvasRef.current;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const engine = new GameEngine(canvas);
    engineRef.current = engine;
    
    engine.onCollision = (collisionData) => {
      setCollision(collisionData);
      
      if (collisionData.type === 'item') {
        setScore(engine.player.score);
        setTimeout(() => setCollision(null), 1500);
      } else if (collisionData.type === 'npc') {
        setTimeout(() => {
          if (collision?.type === 'npc') setCollision(null);
        }, 3000);
      }
    };
    
    engine.loadSpriteSheet().then(() => {
      engine.initWorld();
      engine.start();
      setGameLoaded(true);
    });
    
    const handleKeyDown = (e) => {
      keysPressed.current.add(e.key);
      
      if (e.key === 'ArrowLeft' || e.key === 'a') {
        engine.movePlayer(-1);
      } else if (e.key === 'ArrowRight' || e.key === 'd') {
        engine.movePlayer(1);
      } else if (e.key === 'Enter' || e.key === ' ') {
        if (collision && (collision.target.interactable || collision.target.hasDialog)) {
          setShowDialog(true);
        }
      }
    };
    
    const handleKeyUp = (e) => {
      keysPressed.current.delete(e.key);
      
      if ((e.key === 'ArrowLeft' || e.key === 'a') && !keysPressed.current.has('ArrowRight') && !keysPressed.current.has('d')) {
        engine.stopPlayer();
      } else if ((e.key === 'ArrowRight' || e.key === 'd') && !keysPressed.current.has('ArrowLeft') && !keysPressed.current.has('a')) {
        engine.stopPlayer();
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    const handleResize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      engine.width = canvas.width;
      engine.height = canvas.height;
    };
    
    window.addEventListener('resize', handleResize);
    
    return () => {
      engine.stop();
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  const getCollisionIcon = () => {
    if (!collision) return null;
    
    switch (collision.type) {
      case 'building': return collision.target.icon;
      case 'item': return collision.target.icon;
      case 'npc': return <User className="inline" size={20} />;
      default: return <MapPin size={20} />;
    }
  };

  return (
    <div className="relative w-full h-screen overflow-hidden bg-black">
      <canvas ref={canvasRef} className="absolute inset-0" />
      
      {gameLoaded && (
        <>
          <div className="absolute top-4 left-4 bg-black/80 text-white px-4 py-3 rounded-lg text-sm">
            <div className="font-bold mb-2 text-yellow-400">Controls:</div>
            <div>‚Üê ‚Üí or A/D: Move</div>
            <div>Enter/Space: Interact</div>
          </div>
          
          <div className="absolute top-4 right-4 bg-black/80 text-white px-6 py-3 rounded-lg">
            <div className="text-2xl font-bold text-yellow-400">Score: {score}</div>
          </div>
          
          {collision && (
            <div className="absolute top-20 left-1/2 -translate-x-1/2 bg-gradient-to-r from-yellow-400 to-orange-500 text-white px-6 py-3 rounded-full font-bold flex items-center gap-2 animate-bounce shadow-lg">
              {getCollisionIcon()}
              {collision.type === 'building' && (
                <>
                  {collision.target.nameEn} ({collision.target.name})
                  {collision.target.interactable && (
                    <span className="ml-2 text-xs bg-white text-black px-2 py-1 rounded">
                      Press ENTER
                    </span>
                  )}
                </>
              )}
              {collision.type === 'item' && (
                <span>+{collision.target.points} points!</span>
              )}
              {collision.type === 'npc' && (
                <>
                  Met {collision.target.type}!
                  <span className="ml-2 text-xs bg-white text-black px-2 py-1 rounded">
                    Press ENTER to talk
                  </span>
                </>
              )}
            </div>
          )}
          
          {collision && (collision.target.interactable || collision.target.hasDialog) && (
            <div className="absolute bottom-20 left-1/2 -translate-x-1/2">
              <button
                onClick={() => setShowDialog(true)}
                className="bg-blue-500 hover:bg-blue-600 text-white px-8 py-4 rounded-xl font-bold flex items-center gap-2 transition-all shadow-2xl text-lg"
              >
                <MessageCircle size={24} />
                {collision.type === 'building' ? 'Enter / ÂÖ•„Çã' : 'Talk / Ë©±„Åô'}
              </button>
            </div>
          )}
          
          {showDialog && collision && (
            <div className="absolute inset-0 bg-black/90 flex items-center justify-center z-50">
              <div className="bg-white rounded-2xl p-8 max-w-2xl w-full mx-4 shadow-2xl">
                <div className="text-3xl font-bold mb-4 text-gray-800 flex items-center gap-3">
                  <span className="text-5xl">{collision.target.icon || 'üë§'}</span>
                  {collision.type === 'building' ? collision.target.nameEn : collision.target.type}
                </div>
                
                <div className="bg-gradient-to-r from-blue-50 to-purple-50 p-6 rounded-xl mb-6 border-2 border-blue-200">
                  {collision.type === 'npc' && collision.target.dialog && (
                    <>
                      <div className="text-2xl mb-3 text-gray-800 font-bold">
                        {collision.target.dialog.jp}
                      </div>
                      <div className="text-lg text-gray-600">
                        {collision.target.dialog.en}
                      </div>
                    </>
                  )}
                  {collision.type === 'building' && (
                    <>
                      <div className="text-2xl mb-3 text-gray-800 font-bold">
                        {collision.target.type === 'shop' && '„ÅÑ„Çâ„Å£„Åó„ÇÉ„ÅÑ„Åæ„ÅõÔºÅ'}
                        {collision.target.type === 'restaurant' && '„ÅîÊ≥®Êñá„ÅØÔºü'}
                        {collision.target.type === 'house' && '„Åì„Çì„Å´„Å°„ÅØÔºÅ'}
                        {collision.target.type === 'school' && 'Â≠¶Ê†°„Å∏„Çà„ÅÜ„Åì„ÅùÔºÅ'}
                      </div>
                      <div className="text-lg text-gray-600">
                        {collision.target.type === 'shop' && 'Welcome to the store!'}
                        {collision.target.type === 'restaurant' && 'What would you like to order?'}
                        {collision.target.type === 'house' && 'Hello!'}
                        {collision.target.type === 'school' && 'Welcome to school!'}
                      </div>
                    </>
                  )}
                </div>
                
                <div className="space-y-3 mb-6">
                  <button className="w-full bg-green-500 hover:bg-green-600 text-white px-6 py-4 rounded-xl transition-all text-left font-bold">
                    A) „ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„Åô (Thank you)
                  </button>
                  <button className="w-full bg-green-500 hover:bg-green-600 text-white px-6 py-4 rounded-xl transition-all text-left font-bold">
                    B) „Åì„Çå„ÅØ„ÅÑ„Åè„Çâ„Åß„Åô„ÅãÔºü (How much is this?)
                  </button>
                  <button className="w-full bg-green-500 hover:bg-green-600 text-white px-6 py-4 rounded-xl transition-all text-left font-bold">
                    C) „Åæ„ÅüÊù•„Åæ„Åô (I'll come again)
                  </button>
                </div>
                
                <button
                  onClick={() => setShowDialog(false)}
                  className="w-full bg-gray-300 hover:bg-gray-400 text-gray-800 px-6 py-3 rounded-xl transition-all font-bold"
                >
                  Close / Èñâ„Åò„Çã
                </button>
              </div>
            </div>
          )}
          
          <div className="absolute bottom-4 right-4 bg-black/80 text-white px-4 py-3 rounded-lg text-xs max-w-sm">
            <div className="font-bold mb-2 text-yellow-400">Architecture Highlights:</div>
            <div className="space-y-1 text-gray-300">
              <div>‚úì Spatial Grid: Variable object sizes</div>
              <div>‚úì 4 Object types: Buildings, Items, NPCs, BG</div>
              <div>‚úì Dynamic collision detection</div>
              <div>‚úì Optimized viewport rendering</div>
            </div>
          </div>
        </>
      )}
    </div>
  );
}