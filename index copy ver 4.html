<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Japanese City Side-Scrolling Game</title>

    <!-- React & ReactDOM from CDN -->
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>

    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        overflow: hidden;
      }

      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        background: black;
      }

      canvas {
        position: absolute;
        inset: 0;
      }

      .ui-panel {
        position: absolute;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 14px;
      }

      .controls {
        top: 16px;
        left: 16px;
      }

      .controls-title {
        font-weight: bold;
        margin-bottom: 8px;
        color: #fbbf24;
      }

      .score {
        top: 16px;
        right: 16px;
        padding: 12px 24px;
      }

      .score-text {
        font-size: 24px;
        font-weight: bold;
        color: #fbbf24;
      }

      .collision-indicator {
        position: absolute;
        top: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: linear-gradient(to right, #fbbf24, #f97316);
        color: white;
        padding: 12px 24px;
        border-radius: 9999px;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 8px;
        animation: bounce 1s infinite;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
      }

      @keyframes bounce {
        0%,
        100% {
          transform: translateX(-50%) translateY(0);
        }
        50% {
          transform: translateX(-50%) translateY(-10px);
        }
      }

      .interaction-hint {
        margin-left: 8px;
        font-size: 12px;
        background: white;
        color: black;
        padding: 4px 8px;
        border-radius: 4px;
      }

      .interact-button {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        background: #3b82f6;
        color: white;
        padding: 16px 32px;
        border-radius: 12px;
        font-weight: bold;
        font-size: 18px;
        display: flex;
        align-items: center;
        gap: 8px;
        border: none;
        cursor: pointer;
        transition: all 0.3s;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
      }

      .interact-button:hover {
        background: #2563eb;
        transform: translateX(-50%) scale(1.05);
      }

      .dialog-overlay {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 50;
      }

      .dialog-box {
        background: white;
        border-radius: 16px;
        padding: 32px;
        max-width: 672px;
        width: 100%;
        margin: 16px;
        box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
      }

      .dialog-title {
        font-size: 30px;
        font-weight: bold;
        margin-bottom: 16px;
        color: #1f2937;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .dialog-icon {
        font-size: 48px;
      }

      .dialog-content {
        background: linear-gradient(to right, #eff6ff, #faf5ff);
        padding: 24px;
        border-radius: 12px;
        margin-bottom: 24px;
        border: 2px solid #bfdbfe;
      }

      .dialog-jp {
        font-size: 24px;
        margin-bottom: 12px;
        color: #1f2937;
        font-weight: bold;
      }

      .dialog-en {
        font-size: 18px;
        color: #4b5563;
      }

      .dialog-options {
        display: flex;
        flex-direction: column;
        gap: 12px;
        margin-bottom: 24px;
      }

      .option-button {
        width: 100%;
        background: #22c55e;
        color: white;
        padding: 16px 24px;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        transition: all 0.3s;
        text-align: left;
        font-weight: bold;
        font-size: 16px;
      }

      .option-button:hover {
        background: #16a34a;
      }

      .close-button {
        width: 100%;
        background: #d1d5db;
        color: #1f2937;
        padding: 12px 24px;
        border-radius: 12px;
        border: none;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: bold;
        font-size: 16px;
      }

      .close-button:hover {
        background: #9ca3af;
      }

      .info-panel {
        position: absolute;
        bottom: 16px;
        right: 16px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 16px;
        border-radius: 8px;
        font-size: 12px;
        max-width: 384px;
      }

      .info-title {
        font-weight: bold;
        margin-bottom: 8px;
        color: #fbbf24;
      }

      .info-list {
        display: flex;
        flex-direction: column;
        gap: 4px;
        color: #d1d5db;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // ============================================
      // SPATIAL GRID
      // ============================================
      class SpatialGrid {
        constructor(cellSize = 200) {
          this.cellSize = cellSize;
          this.grid = new Map();
        }

        getGridKey(x) {
          return Math.floor(x / this.cellSize);
        }

        insert(obj) {
          const startKey = this.getGridKey(obj.x);
          const endKey = this.getGridKey(obj.x + (obj.width || this.cellSize));

          for (let key = startKey; key <= endKey; key++) {
            if (!this.grid.has(key)) {
              this.grid.set(key, []);
            }
            if (!this.grid.get(key).includes(obj)) {
              this.grid.get(key).push(obj);
            }
          }

          obj._gridKeys = { start: startKey, end: endKey };
        }

        remove(obj) {
          if (!obj._gridKeys) return;

          for (let key = obj._gridKeys.start; key <= obj._gridKeys.end; key++) {
            if (this.grid.has(key)) {
              const bucket = this.grid.get(key);
              const index = bucket.indexOf(obj);
              if (index > -1) {
                bucket.splice(index, 1);
              }
            }
          }

          delete obj._gridKeys;
        }

        update(obj) {
          this.remove(obj);
          this.insert(obj);
        }

        query(left, right, objectType = null) {
          const startKey = this.getGridKey(left);
          const endKey = this.getGridKey(right);
          const results = new Set();

          for (let key = startKey; key <= endKey; key++) {
            if (this.grid.has(key)) {
              this.grid.get(key).forEach((obj) => {
                if (!objectType || obj.objectType === objectType) {
                  results.add(obj);
                }
              });
            }
          }

          return Array.from(results);
        }

        getStats() {
          let totalObjects = 0;
          this.grid.forEach((bucket) => (totalObjects += bucket.length));
          return {
            buckets: this.grid.size,
            totalObjects: totalObjects,
          };
        }
      }

      // ============================================
      // GAME ENGINE
      // ============================================
      class GameEngine {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext("2d", { alpha: false });
          this.width = canvas.width;
          this.height = canvas.height;

          this.camera = { x: 0, targetX: 0, smoothing: 0.1 };
          this.worldWidth = 40000;
          this.spatialGrid = new SpatialGrid(200);

          this.player = null;
          this.backgrounds = [];
          this.buildings = [];
          this.items = [];
          this.npcs = [];

          this.lastTime = 0;
          this.fps = 0;
          this.running = false;

          this.spriteSheet = null;
          this.spriteLoaded = false;

          this.onCollision = null;
          this.currentCollisions = new Map();
        }

        async loadSpriteSheet() {
          return new Promise((resolve) => {
            this.spriteSheet = document.createElement("canvas");
            this.spriteSheet.width = 40000;
            this.spriteSheet.height = 500;
            const ctx = this.spriteSheet.getContext("2d");

            for (let i = 0; i < 200; i++) {
              const x = i * 200;
              const hue = ((i * 360) / 200) % 360;

              ctx.fillStyle = `hsl(${hue}, 40%, ${40 + Math.random() * 20}%)`;
              ctx.fillRect(x, 0, 200, 500);

              if (i % 5 === 0) {
                ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
                ctx.fillRect(x + 10, 200, 180, 300);
              } else if (i % 3 === 0) {
                ctx.fillStyle = `hsl(${hue}, 50%, 40%)`;
                ctx.fillRect(x + 30, 250, 140, 250);
              }
            }

            this.spriteLoaded = true;
            resolve();
          });
        }

        initWorld() {
          const layouts = [
            { width: 150, type: "narrow" },
            { width: 200, type: "normal" },
            { width: 250, type: "wide" },
            { width: 300, type: "plaza" },
          ];

          let currentX = 0;
          let cellIndex = 0;

          while (currentX < this.worldWidth) {
            const layout = layouts[Math.floor(Math.random() * layouts.length)];

            const cell = {
              id: `bg-${cellIndex}`,
              objectType: "background",
              type: layout.type,
              x: currentX,
              y: 0,
              width: layout.width,
              height: 500,
              spriteX: Math.floor(currentX / 200) * 200,
            };

            this.backgrounds.push(cell);
            this.spatialGrid.insert(cell);

            currentX += layout.width;
            cellIndex++;
          }

          for (let i = 0; i < 50; i++) {
            const buildingTypes = [
              {
                type: "shop",
                width: 180,
                height: 250,
                color: "#FF6B6B",
                icon: "🏪",
                name: "コンビニ",
                nameEn: "Convenience Store",
              },
              {
                type: "restaurant",
                width: 220,
                height: 280,
                color: "#4ECDC4",
                icon: "🍜",
                name: "レストラン",
                nameEn: "Restaurant",
              },
              {
                type: "house",
                width: 160,
                height: 200,
                color: "#95E1D3",
                icon: "🏠",
                name: "家",
                nameEn: "House",
              },
              {
                type: "school",
                width: 300,
                height: 350,
                color: "#F38181",
                icon: "🏫",
                name: "学校",
                nameEn: "School",
              },
            ];

            const template =
              buildingTypes[Math.floor(Math.random() * buildingTypes.length)];

            const building = {
              id: `building-${i}`,
              objectType: "building",
              ...template,
              x: Math.random() * (this.worldWidth - template.width),
              y: 500 - template.height,
              interactable: true,
              hasQuest: Math.random() > 0.7,
            };

            this.buildings.push(building);
            this.spatialGrid.insert(building);
          }

          for (let i = 0; i < 30; i++) {
            const itemTypes = [
              {
                type: "coin",
                width: 30,
                height: 30,
                color: "#FFD700",
                icon: "💰",
                points: 10,
              },
              {
                type: "book",
                width: 35,
                height: 35,
                color: "#8B4513",
                icon: "📚",
                points: 50,
              },
              {
                type: "gift",
                width: 40,
                height: 40,
                color: "#FF1493",
                icon: "🎁",
                points: 100,
              },
            ];

            const template =
              itemTypes[Math.floor(Math.random() * itemTypes.length)];

            const item = {
              id: `item-${i}`,
              objectType: "item",
              ...template,
              x: Math.random() * this.worldWidth,
              y: 400,
              collected: false,
              bobOffset: Math.random() * Math.PI * 2,
            };

            this.items.push(item);
            this.spatialGrid.insert(item);
          }

          for (let i = 0; i < 8; i++) {
            const npcTypes = [
              {
                type: "student",
                width: 50,
                height: 90,
                color: "#4A90E2",
                speed: 1.5,
              },
              {
                type: "elderly",
                width: 45,
                height: 85,
                color: "#9B59B6",
                speed: 0.8,
              },
              {
                type: "businessman",
                width: 55,
                height: 95,
                color: "#34495E",
                speed: 2,
              },
            ];

            const template =
              npcTypes[Math.floor(Math.random() * npcTypes.length)];

            const npc = {
              id: `npc-${i}`,
              objectType: "npc",
              ...template,
              x: Math.random() * this.worldWidth,
              y: 330,
              vx: (Math.random() - 0.5) * 2 * template.speed,
              hasDialog: true,
              dialog: this.getRandomDialog(template.type),
            };

            this.npcs.push(npc);
            this.spatialGrid.insert(npc);
          }

          this.player = {
            id: "player",
            objectType: "player",
            x: 400,
            y: 320,
            width: 60,
            height: 100,
            vx: 0,
            speed: 5,
            score: 0,
          };
        }

        getRandomDialog(npcType) {
          const dialogs = {
            student: [
              { jp: "こんにちは！", en: "Hello!" },
              { jp: "勉強は大変です。", en: "Studying is hard." },
            ],
            elderly: [
              { jp: "いい天気ですね。", en: "Nice weather, isn't it?" },
              { jp: "ゆっくり歩きましょう。", en: "Let's walk slowly." },
            ],
            businessman: [
              { jp: "急いでいます！", en: "I'm in a hurry!" },
              { jp: "会議に遅れます。", en: "I'll be late for the meeting." },
            ],
          };

          const list = dialogs[npcType] || dialogs.student;
          return list[Math.floor(Math.random() * list.length)];
        }

        update(deltaTime) {
          if (this.player.vx !== 0) {
            this.player.x += this.player.vx;
            this.player.x = Math.max(
              0,
              Math.min(this.worldWidth - this.player.width, this.player.x)
            );

            this.camera.targetX =
              this.player.x - this.width / 2 + this.player.width / 2;
            this.camera.targetX = Math.max(
              0,
              Math.min(this.worldWidth - this.width, this.camera.targetX)
            );
          }

          this.camera.x +=
            (this.camera.targetX - this.camera.x) * this.camera.smoothing;

          this.npcs.forEach((npc) => {
            const oldX = npc.x;
            npc.x += npc.vx;

            if (npc.x < 0 || npc.x > this.worldWidth - npc.width) {
              npc.vx *= -1;
            }

            if (Math.abs(npc.x - oldX) > 5) {
              this.spatialGrid.update(npc);
            }
          });

          this.items.forEach((item) => {
            if (!item.collected) {
              item.bobOffset += 0.05;
            }
          });

          this.checkCollisions();
        }

        checkCollisions() {
          const viewport = {
            left: this.player.x - 100,
            right: this.player.x + this.player.width + 100,
          };

          const newCollisions = new Map();

          const nearbyBuildings = this.spatialGrid.query(
            viewport.left,
            viewport.right,
            "building"
          );
          nearbyBuildings.forEach((building) => {
            if (this.checkAABB(this.player, building)) {
              newCollisions.set(building.id, {
                type: "building",
                target: building,
              });
              if (!this.currentCollisions.has(building.id)) {
                if (this.onCollision) {
                  this.onCollision({ type: "building", target: building });
                }
              }
            }
          });

          const nearbyItems = this.spatialGrid.query(
            viewport.left,
            viewport.right,
            "item"
          );
          nearbyItems.forEach((item) => {
            if (!item.collected && this.checkAABB(this.player, item)) {
              item.collected = true;
              this.player.score += item.points;
              this.spatialGrid.remove(item);
              if (this.onCollision) {
                this.onCollision({ type: "item", target: item });
              }
            }
          });

          const nearbyNPCs = this.spatialGrid.query(
            viewport.left,
            viewport.right,
            "npc"
          );
          nearbyNPCs.forEach((npc) => {
            if (this.checkAABB(this.player, npc)) {
              newCollisions.set(npc.id, { type: "npc", target: npc });
              if (!this.currentCollisions.has(npc.id)) {
                if (this.onCollision) {
                  this.onCollision({ type: "npc", target: npc });
                }
              }
            }
          });

          this.currentCollisions = newCollisions;
        }

        checkAABB(a, b) {
          return (
            a.x < b.x + b.width &&
            a.x + a.width > b.x &&
            a.y < b.y + b.height &&
            a.y + a.height > b.y
          );
        }

        render() {
          this.ctx.fillStyle = "#87CEEB";
          this.ctx.fillRect(0, 0, this.width, this.height);

          if (!this.spriteLoaded) return;

          this.backgrounds.forEach((bg) => {
            const screenX = bg.x - this.camera.x;
            if (screenX > -bg.width && screenX < this.width) {
              this.ctx.drawImage(
                this.spriteSheet,
                bg.spriteX,
                0,
                200,
                500,
                screenX,
                bg.y,
                bg.width,
                bg.height
              );
            }
          });

          this.items.forEach((item) => {
            if (item.collected) return;
            const screenX = item.x - this.camera.x;
            if (screenX > -item.width && screenX < this.width) {
              const bobY = Math.sin(item.bobOffset) * 10;
              this.ctx.fillStyle = item.color;
              this.ctx.fillRect(
                screenX,
                item.y + bobY,
                item.width,
                item.height
              );
              this.ctx.font = "24px Arial";
              this.ctx.fillText(item.icon, screenX + 5, item.y + bobY + 25);
            }
          });

          this.buildings.forEach((building) => {
            const screenX = building.x - this.camera.x;
            if (screenX > -building.width && screenX < this.width) {
              this.ctx.fillStyle = building.color;
              this.ctx.fillRect(
                screenX,
                building.y,
                building.width,
                building.height
              );
              this.ctx.strokeStyle = "#333";
              this.ctx.lineWidth = 3;
              this.ctx.strokeRect(
                screenX,
                building.y,
                building.width,
                building.height
              );
              this.ctx.font = "bold 40px Arial";
              this.ctx.fillText(
                building.icon,
                screenX + building.width / 2 - 20,
                building.y + 60
              );
              if (building.hasQuest) {
                this.ctx.fillStyle = "#FFD700";
                this.ctx.fillText(
                  "!",
                  screenX + building.width - 30,
                  building.y + 40
                );
              }
            }
          });

          this.npcs.forEach((npc) => {
            const screenX = npc.x - this.camera.x;
            if (screenX > -npc.width && screenX < this.width) {
              this.ctx.fillStyle = npc.color;
              this.ctx.fillRect(screenX, npc.y, npc.width, npc.height);
              this.ctx.fillStyle = "#000";
              this.ctx.fillRect(screenX + 12, npc.y + 20, 10, 10);
              this.ctx.fillRect(screenX + 28, npc.y + 20, 10, 10);
            }
          });

          const playerScreenX = this.player.x - this.camera.x;
          this.ctx.fillStyle = "#FF6B6B";
          this.ctx.fillRect(
            playerScreenX,
            this.player.y,
            this.player.width,
            this.player.height
          );
          this.ctx.fillStyle = "#000";
          this.ctx.fillRect(playerScreenX + 15, this.player.y + 25, 12, 12);
          this.ctx.fillRect(playerScreenX + 33, this.player.y + 25, 12, 12);
          this.ctx.fillStyle = "#FFF";
          this.ctx.fillRect(playerScreenX + 20, this.player.y + 60, 20, 5);

          this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          this.ctx.fillRect(10, 10, 200, 90);
          this.ctx.fillStyle = "#0F0";
          this.ctx.font = "14px monospace";
          this.ctx.fillText(`FPS: ${this.fps}`, 20, 30);
          this.ctx.fillText(`Score: ${this.player.score}`, 20, 50);
          const stats = this.spatialGrid.getStats();
          this.ctx.fillText(`Grid: ${stats.buckets} buckets`, 20, 70);
          this.ctx.fillText(`Objects: ${stats.totalObjects}`, 20, 90);
        }

        gameLoop(currentTime) {
          if (!this.running) return;
          const deltaTime = currentTime - this.lastTime;
          this.lastTime = currentTime;
          this.fps = Math.round(1000 / deltaTime);
          this.update(deltaTime);
          this.render();
          requestAnimationFrame((time) => this.gameLoop(time));
        }

        start() {
          this.running = true;
          this.lastTime = performance.now();
          requestAnimationFrame((time) => this.gameLoop(time));
        }

        stop() {
          this.running = false;
        }

        movePlayer(direction) {
          this.player.vx = direction * this.player.speed;
        }

        stopPlayer() {
          this.player.vx = 0;
        }
      }

      // ============================================
      // REACT COMPONENT
      // ============================================
      function JapaneseCityGame() {
        const canvasRef = useRef(null);
        const engineRef = useRef(null);
        const [collision, setCollision] = useState(null);
        const [gameLoaded, setGameLoaded] = useState(false);
        const [showDialog, setShowDialog] = useState(false);
        const [score, setScore] = useState(0);
        const keysPressed = useRef(new Set());

        useEffect(() => {
          const canvas = canvasRef.current;
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;

          const engine = new GameEngine(canvas);
          engineRef.current = engine;

          engine.onCollision = (collisionData) => {
            setCollision(collisionData);
            if (collisionData.type === "item") {
              setScore(engine.player.score);
              setTimeout(() => setCollision(null), 1500);
            } else if (collisionData.type === "npc") {
              setTimeout(() => setCollision(null), 3000);
            }
          };

          engine.loadSpriteSheet().then(() => {
            engine.initWorld();
            engine.start();
            setGameLoaded(true);
          });

          const handleKeyDown = (e) => {
            keysPressed.current.add(e.key);
            if (e.key === "ArrowLeft" || e.key === "a") {
              engine.movePlayer(-1);
            } else if (e.key === "ArrowRight" || e.key === "d") {
              engine.movePlayer(1);
            } else if (e.key === "Enter" || e.key === " ") {
              if (
                collision &&
                (collision.target.interactable || collision.target.hasDialog)
              ) {
                setShowDialog(true);
              }
            }
          };

          const handleKeyUp = (e) => {
            keysPressed.current.delete(e.key);
            if (
              (e.key === "ArrowLeft" || e.key === "a") &&
              !keysPressed.current.has("ArrowRight") &&
              !keysPressed.current.has("d")
            ) {
              engine.stopPlayer();
            } else if (
              (e.key === "ArrowRight" || e.key === "d") &&
              !keysPressed.current.has("ArrowLeft") &&
              !keysPressed.current.has("a")
            ) {
              engine.stopPlayer();
            }
          };

          window.addEventListener("keydown", handleKeyDown);
          window.addEventListener("keyup", handleKeyUp);

          const handleResize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            engine.width = canvas.width;
            engine.height = canvas.height;
          };

          window.addEventListener("resize", handleResize);

          return () => {
            engine.stop();
            window.removeEventListener("keydown", handleKeyDown);
            window.removeEventListener("keyup", handleKeyUp);
            window.removeEventListener("resize", handleResize);
          };
        }, []);

        const getCollisionIcon = () => {
          if (!collision) return null;
          if (collision.type === "building") return collision.target.icon;
          if (collision.type === "item") return collision.target.icon;
          if (collision.type === "npc") return "👤";
          return "📍";
        };

        return (
          <div className="container">
            <canvas ref={canvasRef} />

            {gameLoaded && (
              <>
                <div className="ui-panel controls">
                  <div className="controls-title">Controls:</div>
                  <div>← → or A/D: Move</div>
                  <div>Enter/Space: Interact</div>
                </div>

                <div className="ui-panel score">
                  <div className="score-text">Score: {score}</div>
                </div>

                {collision && (
                  <div className="collision-indicator">
                    <span>{getCollisionIcon()}</span>
                    {collision.type === "building" && (
                      <>
                        {collision.target.nameEn} ({collision.target.name})
                        {collision.target.interactable && (
                          <span className="interaction-hint">Press ENTER</span>
                        )}
                      </>
                    )}
                    {collision.type === "item" && (
                      <span>+{collision.target.points} points!</span>
                    )}
                    {collision.type === "npc" && (
                      <>
                        Met {collision.target.type}!
                        <span className="interaction-hint">
                          Press ENTER to talk
                        </span>
                      </>
                    )}
                  </div>
                )}

                {collision &&
                  (collision.target.interactable ||
                    collision.target.hasDialog) && (
                    <button
                      className="interact-button"
                      onClick={() => setShowDialog(true)}
                    >
                      💬{" "}
                      {collision.type === "building"
                        ? "Enter / 入る"
                        : "Talk / 話す"}
                    </button>
                  )}

                {showDialog && collision && (
                  <div className="dialog-overlay">
                    <div className="dialog-box">
                      <div className="dialog-title">
                        <span className="dialog-icon">
                          {collision.target.icon || "👤"}
                        </span>
                        {collision.type === "building"
                          ? collision.target.nameEn
                          : collision.target.type}
                      </div>

                      <div className="dialog-content">
                        {collision.type === "npc" &&
                          collision.target.dialog && (
                            <>
                              <div className="dialog-jp">
                                {collision.target.dialog.jp}
                              </div>
                              <div className="dialog-en">
                                {collision.target.dialog.en}
                              </div>
                            </>
                          )}
                        {collision.type === "building" && (
                          <>
                            <div className="dialog-jp">
                              {collision.target.type === "shop" &&
                                "いらっしゃいませ！"}
                              {collision.target.type === "restaurant" &&
                                "ご注文は？"}
                              {collision.target.type === "house" &&
                                "こんにちは！"}
                              {collision.target.type === "school" &&
                                "学校へようこそ！"}
                            </div>
                            <div className="dialog-en">
                              {collision.target.type === "shop" &&
                                "Welcome to the store!"}
                              {collision.target.type === "restaurant" &&
                                "What would you like to order?"}
                              {collision.target.type === "house" && "Hello!"}
                              {collision.target.type === "school" &&
                                "Welcome to school!"}
                            </div>
                          </>
                        )}
                      </div>

                      <div className="dialog-options">
                        <button className="option-button">
                          A) ありがとうございます (Thank you)
                        </button>
                        <button className="option-button">
                          B) これはいくらですか？ (How much is this?)
                        </button>
                        <button className="option-button">
                          C) また来ます (I'll come again)
                        </button>
                      </div>

                      <button
                        className="close-button"
                        onClick={() => setShowDialog(false)}
                      >
                        Close / 閉じる
                      </button>
                    </div>
                  </div>
                )}

                <div className="info-panel">
                  <div className="info-title">Architecture Highlights:</div>
                  <div className="info-list">
                    <div>✓ Spatial Grid: Variable object sizes</div>
                    <div>✓ 4 Object types: Buildings, Items, NPCs, BG</div>
                    <div>✓ Dynamic collision detection</div>
                    <div>✓ Optimized viewport rendering</div>
                  </div>
                </div>
              </>
            )}
          </div>
        );
      }

      // Render app
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<JapaneseCityGame />);
    </script>
  </body>
</html>
